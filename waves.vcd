$version Generated by VerilatedVcd $end
$timescale 1ps $end
 $scope module TOP $end
  $scope module top $end
   $var wire 1 # clk $end
   $var wire 1 $ reset $end
   $scope module slave_if $end
    $var wire 32 & WIDTH [31:0] $end
    $var wire 1 C tvalid $end
    $var wire 1 D tready $end
    $var wire 8 E tdata [7:0] $end
    $var wire 1 F tlast $end
   $upscope $end
   $scope module master_if $end
    $var wire 32 & WIDTH [31:0] $end
    $var wire 1 G tvalid $end
    $var wire 1 H tready $end
    $var wire 8 I tdata [7:0] $end
    $var wire 1 J tlast $end
   $upscope $end
   $scope module npu_top_inst $end
    $var wire 32 % ARRAY_SIZE [31:0] $end
    $var wire 32 & DATA_WIDTH [31:0] $end
    $var wire 1 # clk $end
    $var wire 1 $ rst_n $end
    $scope module s_axis $end
     $var wire 32 & WIDTH [31:0] $end
     $var wire 1 C tvalid $end
     $var wire 1 D tready $end
     $var wire 8 E tdata [7:0] $end
     $var wire 1 F tlast $end
    $upscope $end
    $scope module m_axis $end
     $var wire 32 & WIDTH [31:0] $end
     $var wire 1 G tvalid $end
     $var wire 1 H tready $end
     $var wire 8 I tdata [7:0] $end
     $var wire 1 J tlast $end
    $upscope $end
    $var wire 8 ' row_bus[0] [7:0] $end
    $var wire 8 ( row_bus[1] [7:0] $end
    $var wire 8 ) row_bus[2] [7:0] $end
    $var wire 8 * row_bus[3] [7:0] $end
    $var wire 8 + col_bus[0] [7:0] $end
    $var wire 8 , col_bus[1] [7:0] $end
    $var wire 8 - col_bus[2] [7:0] $end
    $var wire 8 . col_bus[3] [7:0] $end
    $var wire 1 / opcode $end
    $var wire 1 0 start $end
    $var wire 1 1 busy $end
    $var wire 1 2 done $end
    $var wire 1 3 sram_read_en $end
    $var wire 1 4 pe_array_en $end
    $var wire 1 5 ppu_en $end
    $var wire 1 6 data_in $end
    $var wire 1 7 relu_en $end
    $var wire 1 8 data_out $end
    $scope module array_inst $end
     $var wire 32 % ARRAY_SIZE [31:0] $end
     $var wire 32 & DATA_WIDTH [31:0] $end
     $var wire 1 # clk $end
     $var wire 1 $ rst_n $end
     $var wire 8 ' row_in[0] [7:0] $end
     $var wire 8 ( row_in[1] [7:0] $end
     $var wire 8 ) row_in[2] [7:0] $end
     $var wire 8 * row_in[3] [7:0] $end
     $var wire 8 + col_in[0] [7:0] $end
     $var wire 8 , col_in[1] [7:0] $end
     $var wire 8 - col_in[2] [7:0] $end
     $var wire 8 . col_in[3] [7:0] $end
     $var wire 24 9 array_out[0] [23:0] $end
     $var wire 24 : array_out[1] [23:0] $end
     $var wire 24 ; array_out[2] [23:0] $end
     $var wire 24 < array_out[3] [23:0] $end
    $upscope $end
    $scope module ctrl_inst $end
     $var wire 1 # clk $end
     $var wire 1 $ rst_n $end
     $var wire 4 = opcode [3:0] $end
     $var wire 1 0 start $end
     $var wire 1 1 busy $end
     $var wire 1 2 done $end
     $var wire 1 3 sram_read_en $end
     $var wire 1 4 pe_array_en $end
     $var wire 1 5 ppu_en $end
    $upscope $end
    $scope module ppu_gen[0] $end
     $scope module ppu_inst $end
      $var wire 32 & WIDTH [31:0] $end
      $var wire 1 # clk $end
      $var wire 24 > data_in [23:0] $end
      $var wire 1 7 relu_en $end
      $var wire 8 ? data_out [7:0] $end
     $upscope $end
    $upscope $end
    $scope module ppu_gen[1] $end
     $scope module ppu_inst $end
      $var wire 32 & WIDTH [31:0] $end
      $var wire 1 # clk $end
      $var wire 24 > data_in [23:0] $end
      $var wire 1 7 relu_en $end
      $var wire 8 @ data_out [7:0] $end
     $upscope $end
    $upscope $end
    $scope module ppu_gen[2] $end
     $scope module ppu_inst $end
      $var wire 32 & WIDTH [31:0] $end
      $var wire 1 # clk $end
      $var wire 24 > data_in [23:0] $end
      $var wire 1 7 relu_en $end
      $var wire 8 A data_out [7:0] $end
     $upscope $end
    $upscope $end
    $scope module ppu_gen[3] $end
     $scope module ppu_inst $end
      $var wire 32 & WIDTH [31:0] $end
      $var wire 1 # clk $end
      $var wire 24 > data_in [23:0] $end
      $var wire 1 7 relu_en $end
      $var wire 8 B data_out [7:0] $end
     $upscope $end
    $upscope $end
   $upscope $end
  $upscope $end
 $upscope $end
$enddefinitions $end


#0
0#
0$
b00000000000000000000000000000100 %
b00000000000000000000000000001000 &
b00000000 '
b00000000 (
b00000000 )
b00000000 *
b00000000 +
b00000000 ,
b00000000 -
b00000000 .
0/
00
01
02
03
04
05
06
07
08
b000000000000000000000000 9
b000000000000000000000000 :
b000000000000000000000000 ;
b000000000000000000000000 <
b0000 =
b000000000000000000000000 >
b00000000 ?
b00000000 @
b00000000 A
b00000000 B
0C
0D
b00000000 E
0F
0G
0H
b00000000 I
0J
#1
1#
#2
0#
#3
1#
1$
#4
0#
#5
1#
#6
0#
#7
1#
0$
#8
0#
#9
1#
#10
0#
